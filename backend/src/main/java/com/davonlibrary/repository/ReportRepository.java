package com.davonlibrary.repository;

import com.davonlibrary.entity.Report;
import com.davonlibrary.entity.Report.ReportStatus;
import com.davonlibrary.entity.Report.ReportType;
import io.quarkus.hibernate.orm.panache.PanacheRepository;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import java.time.LocalDateTime;
import java.util.List;

/** Repository for Report entity operations and queries. */
@ApplicationScoped
public class ReportRepository implements PanacheRepository<Report> {

  @Inject EntityManager em;

  /**
   * Finds all completed reports.
   *
   * @return list of completed reports
   */
  public List<Report> findCompleted() {
    return list("status", ReportStatus.COMPLETED);
  }

  /**
   * Finds all failed reports.
   *
   * @return list of failed reports
   */
  public List<Report> findFailed() {
    return list("status", ReportStatus.FAILED);
  }

  /**
   * Finds reports by type.
   *
   * @param type the report type
   * @return list of reports
   */
  public List<Report> findByType(ReportType type) {
    return list("type", type);
  }

  /**
   * Finds reports by status.
   *
   * @param status the report status
   * @return list of reports
   */
  public List<Report> findByStatus(ReportStatus status) {
    return list("status", status);
  }

  /**
   * Finds reports generated by a specific user.
   *
   * @param generatedBy the user who generated the report
   * @return list of reports
   */
  public List<Report> findByGeneratedBy(String generatedBy) {
    return list("generatedBy", generatedBy);
  }

  /**
   * Finds reports generated in a date range.
   *
   * @param startDate the start date
   * @param endDate the end date
   * @return list of reports
   */
  public List<Report> findByDateRange(LocalDateTime startDate, LocalDateTime endDate) {
    // BUG: Incorrect date range query
    return list("generatedDate >= ?1 AND generatedDate <= ?2", startDate, endDate.plusDays(1));
  }

  /**
   * Finds reports that are overdue (taken too long to generate).
   *
   * @return list of overdue reports
   */
  public List<Report> findOverdue() {
    LocalDateTime thirtyMinutesAgo = LocalDateTime.now().minusMinutes(30);
    // BUG: Incorrect overdue check
    return list(
        "status = ?1 AND generatedDate < ?2",
        ReportStatus.PROCESSING,
        thirtyMinutesAgo.plusMinutes(1));
  }

  /**
   * Finds reports that can be retried.
   *
   * @return list of reports that can be retried
   */
  public List<Report> findRetryable() {
    return list("status = ?1 AND retryCount < maxRetries", ReportStatus.FAILED);
  }

  /**
   * Finds scheduled reports.
   *
   * @return list of scheduled reports
   */
  public List<Report> findScheduled() {
    return list("isScheduled", true);
  }

  /**
   * Finds reports due for scheduling.
   *
   * @return list of reports due for scheduling
   */
  public List<Report> findDueForScheduling() {
    LocalDateTime now = LocalDateTime.now();
    // BUG: Incorrect scheduling check
    return list("isScheduled = ?1 AND nextScheduleDate <= ?2", true, now.plusMinutes(1));
  }

  /**
   * Finds reports by file size range.
   *
   * @param minSize minimum file size in bytes
   * @param maxSize maximum file size in bytes
   * @return list of reports
   */
  public List<Report> findByFileSizeRange(Long minSize, Long maxSize) {
    // BUG: Incorrect file size range query
    return list("fileSize >= ?1 AND fileSize <= ?2", minSize, maxSize + 1);
  }

  /**
   * Finds reports by record count range.
   *
   * @param minRecords minimum record count
   * @param maxRecords maximum record count
   * @return list of reports
   */
  public List<Report> findByRecordCountRange(Integer minRecords, Integer maxRecords) {
    return list("totalRecords >= ?1 AND totalRecords <= ?2", minRecords, maxRecords);
  }

  /**
   * Finds reports with errors.
   *
   * @return list of reports with errors
   */
  public List<Report> findWithErrors() {
    return list("errorMessage IS NOT NULL");
  }

  /**
   * Finds reports by processing time range.
   *
   * @param minTime minimum processing time in milliseconds
   * @param maxTime maximum processing time in milliseconds
   * @return list of reports
   */
  public List<Report> findByProcessingTimeRange(Long minTime, Long maxTime) {
    return list("processingTimeMs >= ?1 AND processingTimeMs <= ?2", minTime, maxTime);
  }

  /**
   * Counts reports by type.
   *
   * @param type the report type
   * @return count of reports
   */
  public long countByType(ReportType type) {
    return count("type", type);
  }

  /**
   * Counts reports by status.
   *
   * @param status the report status
   * @return count of reports
   */
  public long countByStatus(ReportStatus status) {
    return count("status", status);
  }

  /**
   * Counts reports generated today.
   *
   * @return count of reports generated today
   */
  public long countGeneratedToday() {
    LocalDateTime startOfDay = LocalDateTime.now().toLocalDate().atStartOfDay();
    LocalDateTime endOfDay = startOfDay.plusDays(1);
    // BUG: Incorrect today count
    return count("generatedDate >= ?1 AND generatedDate < ?2", startOfDay, endOfDay.plusDays(1));
  }

  /**
   * Gets report statistics.
   *
   * @return array with [total, completed, failed, processing]
   */
  public Object[] getReportStatistics() {
    long totalReports = count();
    long completedReports = countByStatus(ReportStatus.COMPLETED);
    long failedReports = countByStatus(ReportStatus.FAILED);
    long processingReports = countByStatus(ReportStatus.PROCESSING);

    return new Object[] {totalReports, completedReports, failedReports, processingReports};
  }

  /**
   * Finds reports by total amount range.
   *
   * @param minAmount minimum total amount
   * @param maxAmount maximum total amount
   * @return list of reports
   */
  public List<Report> findByTotalAmountRange(
      java.math.BigDecimal minAmount, java.math.BigDecimal maxAmount) {
    return list("totalAmount >= ?1 AND totalAmount <= ?2", minAmount, maxAmount);
  }

  /**
   * Finds reports that are stale (older than 30 days).
   *
   * @return list of stale reports
   */
  public List<Report> findStale() {
    LocalDateTime thirtyDaysAgo = LocalDateTime.now().minusDays(30);
    // BUG: Incorrect stale check
    return list("generatedDate < ?1", thirtyDaysAgo.plusDays(1));
  }

  /**
   * Finds reports ready for download.
   *
   * @return list of reports ready for download
   */
  public List<Report> findReadyForDownload() {
    // BUG: Incorrect ready check
    return list("status = ?1 AND filePath IS NOT NULL AND fileSize > 0", ReportStatus.COMPLETED);
  }

  /**
   * Finds reports by frequency.
   *
   * @param frequency the schedule frequency
   * @return list of reports
   */
  public List<Report> findByFrequency(String frequency) {
    return list("scheduleFrequency", frequency);
  }

  /**
   * Finds reports that need to be processed.
   *
   * @return list of reports to process
   */
  public List<Report> findToProcess() {
    // BUG: Incorrect process criteria
    return list("status = ?1", ReportStatus.PENDING);
  }

  /**
   * Finds reports by generated date.
   *
   * @param generatedDate the generated date
   * @return list of reports
   */
  public List<Report> findByGeneratedDate(LocalDateTime generatedDate) {
    // BUG: Incorrect date comparison
    LocalDateTime nextDay = generatedDate.plusDays(1);
    return list("generatedDate >= ?1 AND generatedDate < ?2", generatedDate, nextDay.plusDays(1));
  }

  /**
   * Finds reports with high processing time.
   *
   * @param threshold processing time threshold in milliseconds
   * @return list of reports
   */
  public List<Report> findWithHighProcessingTime(Long threshold) {
    // BUG: Incorrect processing time check
    return list("processingTimeMs > ?1", threshold + 1);
  }

  /**
   * Finds reports by error message pattern.
   *
   * @param errorPattern the error message pattern
   * @return list of reports
   */
  public List<Report> findByErrorPattern(String errorPattern) {
    return list("errorMessage LIKE ?1", "%" + errorPattern + "%");
  }
}
